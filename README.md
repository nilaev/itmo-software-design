# Условия домашних заданий по Software Design

## [Лабораторная 1](https://github.com/nilaev/itmo-software-design/tree/main/hw-01)
Цель: получить практический опыт применения динамических проверок в коде (assertions).

Необходимо реализовать структуры данных LRUCache на хешмапе и двусвязном списке. При реализации необходимо самостоятельно продумать 
возможные проверки pre/post-условий и инвариантов класса. Придуманные проверки необходимо добавить в код реализации в виде assertions. 
Класс необходимо покрыть тестами.

Указания:
- использовать LinkedHashMap напрямую нельзя
- задание можно сдавать по почте, в теме письма указать [SD-TASK]


## [Лабораторная 2](https://github.com/nilaev/itmo-software-design/tree/main/hw-02)
Цель: получить практический опыт реализация модульных тестов и тестов, использующих mock-объекты.

Необходимо реализовать компонент, который будет вычислять частоту появления твитов с
определенным хештегом за последние несколько часов. Для выполнения лабораторной
необходимо использовать twitter api (https://dev.twitter.com/rest/public/search) или api любой
другой социальной сети (например, vk не требует авторизации).
На входе компонент должен принимать:
- хештег, по которому будет идти поиск
- N - число часов, за которые необходимо построить диаграмму твитов (1 <= N <= 24)
На выходе нужно выдать массив из N целых чисел - каждое число в массиве определяет число
твитов в соответствующий час.

Указания:
- при выполнении лабораторной рекомендуется применять SOLID-принципы;
- код должен быть покрыт тестами (в том числе mock-тестами и тестами с StubServer)

Примеры из лекции:
https://github.com/akirakozov/example-apps/tree/master/java/mock-example

## [Лабораторная 3](https://github.com/nilaev/itmo-software-design/tree/main/hw-03)
Цель: получить практический опыт применения техник рефакторинга.

Скачайте приложение: https://github.com/akirakozov/software-design/tree/master/java/refactoring

Приложение представляет собой простой web-server, который хранит информацию о товарах и
их цене. Поддержаны такие методы:
- http://localhost:8081/get-products - посмотреть все товары в базе
- http://localhost:8081/add-product?name=iphone6&price=300 - добавить новый товар
- http://localhost:8081/query?command=sum - выполнить некоторый запрос с данными в базе

Необходимо отрефакторить этот код (логика методов не должна измениться), например:
- убрать дублирование
- выделить отдельный слой работы с БД
- выделить отдельный слой формирования html-ответа
- и тд

Указание:
- задание нужно сдавать через e-mail, в заголовке письма указать “[SD-TASK]”
- проект перенести к себе github.com
- сначала добавить тесты (отдельными комитами)
- каждый отдельный рефакторинг делать отдельным комитом
- без истории изменений и тестов баллы буду сниматься

## [Лабораторная 6](https://github.com/nilaev/itmo-software-design/tree/main/hw-06)
Цель: получить практический опыт применения паттернов поведения visitor и state.

Необходимо реализовать калькулятор, который умеет преобразовывать простые арифметические выражения в обратную польскую
запись (ОПЗ) и вычислять их. Пример выражения:

```scala
(23 + 10) * 5 - 3 * (32 + 5) * (10 - 4 * 5) + 8 / 2
```

Выражение может содержать скобки, пробельные символы, цифры и 4 операции: ```+, -, *, /```. Для вычисления выражения его
необходимо сначала разбить на токены:

* По одному токену на каждую скобку и операцию;
* Токен для целых чисел.

Пример:

```scala
(30 + 2) / 8 -> LEFT NUMBER (30) PLUS NUMBER(2) RIGHT DIV NUMBER (8)
```

Далее токены преобразуются к ОПЗ, которая уже не содержит скобок и может быть легко вычислена с помощью стека.

```scala
LEFT NUMBER (30) PLUS NUMBER(2) RIGHT DIV NUMBER (8) ->
  NUMBER(30) NUMBER (2) PLUS NUMBER(8) DIV
```

##### Схема работы калькулятора:

![Pipeline](https://github.com/nilaev/itmo-software-design/tree/main/hw-06/images/pipeline.png)

* Входной набор данных разбирается на отдельные токены Tokenizer'ом;
* ParserVisitor обходит все полученные токены и преобразует их к обратной польской записи;
* Затем токены печатаются PrintVisitor'ом;
* Значение выражения вычисляется СalcVisitor'ом.

Visitor'ы могут использовать стеки и другие структуры данных, чтобы накапливать в себе промежуточные результаты.

Tokenizer проще всего реализовать в виде конечного автомата, который считывает по одному из символов из входного потока
и преобразует их в токены. Сам автомат необходимо реализовать, используя паттерн State.

##### Схема автомата:

![State](https://github.com/nilaev/itmo-software-design/tree/main/hw-06/images/state.png)

##### Скелет классов:

```java
interface Token {
    void accept(TokenVisitor visitor);
}

interface TokenVisitor {
    void visit(NumberToken token);

    void visit(Brace token);

    void visit(Operation token);
}
```

* NumberToken, Brace, Operation реализуют Token.
* Все Visitor реализуют TokenVisitor.

**В итоге** необходимо реализовать программу, которая с консоли считывает входное выражение и выводит в консоль сначала
выражение преобразованное в обратную польскую нотации, а затем вычисленное значение выражения. Если было введено
некорректное выражение, необходимо вывести ошибку.

[Подробнее про ОПЗ и преобразования в нее](https://ru.wikipedia.org/wiki/Обратная_польская_запись)
